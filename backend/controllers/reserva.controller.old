const { validationResult } = require('express-validator');
const { Op } = require('sequelize');
const db = require('../models');
const { v4: uuidv4 } = require('uuid');

// Obtener la instancia de sequelize y los modelos
const { sequelize } = db;
const { Reserva, Tour, Cliente, CuentaCorriente, Cuota } = db.sequelize.models;

// Función para calcular fechas de vencimiento de cuotas
const calcularFechasVencimiento = (fechaInicio, cantidadCuotas) => {
  const fechas = [];
  const fecha = new Date(fechaInicio);
  
  for (let i = 1; i <= cantidadCuotas; i++) {
    // Agregar un mes a la fecha para cada cuota
    const nuevaFecha = new Date(fecha);
    nuevaFecha.setMonth(nuevaFecha.getMonth() + i);
    fechas.push(nuevaFecha.toISOString().split('T')[0]); // Formato YYYY-MM-DD
  }
  
  return fechas;
};

// Verificar que los modelos estén disponibles
if (!Reserva) {
  console.error('Error: No se pudo cargar el modelo Reserva');
  console.log('Modelos disponibles en sequelize:', Object.keys(db.sequelize.models));
  console.log('Modelos disponibles en db:', Object.keys(db).filter(key => typeof db[key] === 'object' && db[key] !== null));
}

if (!Tour) {
  console.error('Error: No se pudo cargar el modelo Tour');
  console.log('Modelos disponibles en sequelize:', Object.keys(db.sequelize.models));
}

// Obtener todas las reservas con paginación y filtros
exports.obtenerReservas = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      search = '', 
      estado = '',
      fechaInicio,
      fechaFin
    } = req.query;

    const offset = (page - 1) * limit;
    
    // Construir condiciones de búsqueda
    const whereClause = {
      activo: true,
    };

    // Filtrar por estado si se proporciona
    if (estado) {
      whereClause.estado = estado;
    }

    // Filtrar por rango de fechas si se proporciona
    if (fechaInicio && fechaFin) {
      whereClause.fecha_reserva = {
        [Op.between]: [fechaInicio, fechaFin],
      };
    }

    // Búsqueda por código o campos del cliente
    if (search) {
      whereClause[Op.or] = [
        { codigo: { [Op.iLike]: `%${search}%` } },
        // La búsqueda por datos del cliente se manejará en la consulta principal
      ];
    }

    // Verificar que el modelo Reserva esté disponible
    if (!Reserva || typeof Reserva.count !== 'function') {
      console.error('Error: El modelo Reserva no está disponible o no tiene el método count');
      return res.status(500).json({
        success: false,
        message: 'Error interno del servidor: Modelo de reserva no disponible',
      });
    }

    // Obtener el total de registros
    const total = await Reserva.count({ where: whereClause });

    // Obtener las reservas con paginación
    const reservas = await Reserva.findAll({
      attributes: [
        'id', 'codigo', 'fecha_reserva', 'cantidad_personas', 
        'precio_unitario', 'estado', 'notas', 'activo', 
        'created_at', 'updated_at'
      ],
      where: whereClause,
      include: [
        {
          model: Cliente,
          as: 'clientes',
          attributes: ['id', 'nombre', 'apellido', 'email', 'telefono'],
          through: { attributes: [] },
          required: false
        },
        {
          model: Tour,
          as: 'tour',
          attributes: ['id', 'nombre', 'destino', 'imagenUrl'],
          where: { activo: true },
          required: true,
        }
      ],
      order: [['fecha_reserva', 'DESC']],
      limit: parseInt(limit, 10),
      offset: parseInt(offset, 10),
    });

    res.status(200).json({
      success: true,
      reservas,
      total,
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      totalPages: Math.ceil(total / limit),
    });
  } catch (error) {
    console.error('Error al obtener las reservas:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener las reservas',
      error: error.message,
    });
  }
};

// Obtener una reserva por ID
exports.obtenerReservaPorId = async (req, res) => {
  try {
    const { id } = req.params;

    const reserva = await Reserva.findByPk(id, {
      include: [
        {
          model: Tour,
          as: 'tour',
          attributes: ['id', 'nombre', 'destino', 'imagenUrl', 'precio'],
        },
      ],
    });

    if (!reserva) {
      return res.status(404).json({
        success: false,
        message: 'Reserva no encontrada',
      });
    }

    res.status(200).json({
      success: true,
      reserva,
    });
  } catch (error) {
    console.error('Error al obtener la reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener la reserva',
      error: error.message,
    });
  }
};

// Crear una nueva reserva
exports.crearReserva = async (req, res) => {
  // Validar los datos de entrada
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      success: false,
      errors: errors.array() 
    });
  }

  const t = await sequelize.transaction();

  try {
    const {
      tour_id,
      clientes = [],
      fecha_reserva,
      cantidad_personas,
      estado = 'pendiente',
      notas,
      referencia,
      descripcion,
      monto_total,
      monto_seña,
      cantidad_cuotas = 1,
      tipo_pago,
      fecha_pago = new Date(),
      // Nuevos campos para tour personalizado
      tour_nombre,
      tour_destino,
      tour_descripcion,
      fecha_inicio,
      fecha_fin
    } = req.body;

    // Validar que se proporcione un tour_id o datos de tour personalizado
    if (!tour_id && !(tour_nombre && tour_destino)) {
      await t.rollback();
      return res.status(400).json({
        success: false,
        message: 'Se requiere un tour existente o los datos completos de un tour personalizado',
      });
    }

    // Si se proporciona un tour_id, verificar que exista
    if (tour_id) {
      const tour = await Tour.findByPk(tour_id, { transaction: t });
      if (!tour) {
        await t.rollback();
        return res.status(404).json({
          success: false,
          message: 'El tour especificado no existe',
        });
      }
    } else {
      // Crear un tour personalizado
      tour = await Tour.create({
        nombre: tour_nombre,
        destino: tour_destino,
        descripcion: tour_descripcion,
        fecha_inicio: fecha_inicio,
        fecha_fin: fecha_fin,
        activo: true,
      }, { transaction: t });
    }

    // Verificar si hay clientes para asociar
    if (clientes && clientes.length === 0) {
      await t.rollback();
      return res.status(400).json({
        success: false,
        message: 'Se requiere al menos un cliente para la reserva',
      });
    }

    // Verificar si hay cupos disponibles si se está actualizando la cantidad de personas
    if (cantidad_personas && tour.cupos_disponibles < cantidad_personas) {
      await t.rollback();
      return res.status(400).json({
        success: false,
        message: 'No hay suficientes cupos disponibles para este tour',
      });
    }

    // Verificar que todos los clientes existan
    const clientesIds = clientes.map(c => c.id).filter(Boolean);
    let clientesExistentes = [];
    
    if (clientesIds.length > 0) {
      clientesExistentes = await Cliente.findAll({
        where: { id: clientesIds },
        transaction: t
      });

      if (clientesExistentes.length !== clientesIds.length) {
        await t.rollback();
        return res.status(404).json({
          success: false,
          message: 'Uno o más clientes no existen en el sistema',
        });
      }
    }
    
    // Asociar clientes a la reserva
    for (const [index, clienteData] of clientes.entries()) {
      const esTitular = index === 0; // El primer cliente es el titular
      let cliente = clientesExistentes.find(c => c.id === clienteData.id);
      
      // Si el cliente no existe, lo creamos
      let clienteDB = cliente.id ? 
        await Cliente.findByPk(cliente.id, { transaction: t }) :
        await Cliente.create({
          nombre: clienteData.nombre,
          apellido: clienteData.apellido || '',
          email: clienteData.email,
          telefono: clienteData.telefono,
          dni: clienteData.dni || null,
          fecha_nacimiento: clienteData.fecha_nacimiento || null,
        }, { transaction: t });
      
      // Asociar cliente a la reserva
      await reserva.addCliente(clienteDB, { 
        through: { 
          tipo_cliente: esTitular ? 'titular' : 'acompanante',
          created_at: new Date(),
          updated_at: new Date()
        },
        transaction: t 
      });
      
      // Crear cuenta corriente para el cliente en esta reserva
      const montoCliente = montoPorPersona;
      const cuentaCorriente = await CuentaCorriente.create(
        {
          reserva_id: reserva.id,
          cliente_id: clienteDB.id,
          monto_total: montoCliente,
          monto_abonado: esTitular ? monto_seña : 0,
          saldo_pendiente: esTitular ? montoCliente - monto_seña : montoCliente,
          cantidad_cuotas: esTitular ? cantidad_cuotas : 1,
          estado: esTitular ? (monto_seña >= montoCliente ? 'pagado' : 'pendiente') : 'pendiente',
        },
        { transaction: t }
      );
      
      // Crear cuotas para el titular
      if (esTitular && cantidad_cuotas > 1) {
        const montoCuota = montoCliente / cantidad_cuotas;
        const fechasVencimiento = calcularFechasVencimiento(fecha_pago || new Date(), cantidad_cuotas);
        
        for (let i = 0; i < cantidad_cuotas; i++) {
          await Cuota.create(
            {
              cuenta_corriente_id: cuentaCorriente.id,
              numero_cuota: i + 1,
              monto: montoCuota,
              fecha_vencimiento: fechasVencimiento[i],
              estado: i === 0 && monto_seña >= montoCuota ? 'pagado' : 'pendiente',
              monto_abonado: i === 0 ? Math.min(monto_seña, montoCuota) : 0,
              fecha_pago: i === 0 && monto_seña >= montoCuota ? new Date() : null,
            },
            { transaction: t }
          );
        }
      } else {
        // Para acompañantes o pagos de contado
        await Cuota.create(
          {
            cuenta_corriente_id: cuentaCorriente.id,
            numero_cuota: 1,
            monto: montoCliente,
            fecha_vencimiento: new Date(fecha_pago),
            estado: 'pendiente',
            monto_abonado: 0,
          },
          { transaction: t }
        );
      }
    }

    // Actualizar los cupos disponibles del tour si corresponde
    if (tour_id) {
      await Tour.update(
        { cupos_disponibles: tour.cupos_disponibles - cantidad_personas },
        { where: { id: tour_id }, transaction: t }
      );
    }

    await t.commit();

    // Obtener la reserva con todos sus datos asociados
    const reservaCreada = await Reserva.findByPk(reserva.id, {
      include: [
        {
          model: Tour,
          as: 'tour',
          attributes: ['id', 'nombre', 'destino', 'imagenUrl'],
        },
        {
          model: Cliente,
          as: 'clientes',
          through: { attributes: ['tipo_cliente'] },
          attributes: ['id', 'nombre', 'apellido', 'email', 'telefono', 'dni']
        },
        {
          model: CuentaCorriente,
          as: 'cuentas_corrientes',
          include: [
            {
              model: Cuota,
              as: 'cuotas',
              attributes: ['id', 'numero_cuota', 'monto', 'monto_abonado', 'fecha_vencimiento', 'fecha_pago', 'estado'],
            },
            {
              model: Cliente,
              as: 'cliente',
              attributes: ['id', 'nombre', 'apellido']
            }
          ],
        },
      ],
    });

    res.status(201).json({
      success: true,
      message: 'Reserva creada exitosamente con su cuenta corriente',
      reserva: reservaCreada,
    });
  } catch (error) {
    await t.rollback();
    console.error('Error al crear la reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear la reserva',
      error: error.message,
    });
  }
};

// Actualizar una reserva existente
exports.actualizarReserva = async (req, res) => {
  // Validar los datos de entrada
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      success: false,
      errors: errors.array() 
    });
  }

  const t = await sequelize.transaction();

  try {
    const { id } = req.params;
    const {
      tour_id,
      nombre_cliente,
      email_cliente,
      telefono_cliente,
      fecha_reserva,
      cantidad_personas,
      estado,
      notas,
    } = req.body;

    // Buscar la reserva existente
    const reserva = await Reserva.findByPk(id, { transaction: t });
    
    if (!reserva) {
      await t.rollback();
      return res.status(404).json({
        success: false,
        message: 'Reserva no encontrada',
      });
    }

    // Verificar si se está cambiando el tour o la cantidad de personas
    const cambiarTour = tour_id && reserva.tour_id !== tour_id;
    const cambiarCantidad = cantidad_personas && reserva.cantidad_personas !== cantidad_personas;

    // Si se está cambiando el tour o la cantidad, verificar disponibilidad
    if (cambiarTour || cambiarCantidad) {
      const tour = await Tour.findByPk(
        cambiarTour ? tour_id : reserva.tour_id,
        { transaction: t }
      );

      if (!tour) {
        await t.rollback();
        return res.status(404).json({
          success: false,
          message: 'El tour especificado no existe',
        });
      }

      // Calcular la nueva cantidad de cupos necesarios
      const cuposNecesarios = cambiarCantidad 
        ? cantidad_personas - reserva.cantidad_personas
        : cantidad_personas || reserva.cantidad_personas;

      if (tour.cupos_disponibles < cuposNecesarios) {
        await t.rollback();
        return res.status(400).json({
          success: false,
          message: 'No hay suficientes cupos disponibles para este tour',
        });
      }

      // Actualizar los cupos del tour
      await Tour.update(
        { 
          cupos_disponibles: tour.cupos_disponibles - cuposNecesarios 
        },
        { 
          where: { id: tour.id },
          transaction: t,
        }
      );

      // Si se cambió de tour, devolver los cupos al tour anterior
      if (cambiarTour && reserva.tour_id !== tour_id) {
        const tourAnterior = await Tour.findByPk(reserva.tour_id, { transaction: t });
        if (tourAnterior) {
          await Tour.update(
            { 
              cupos_disponibles: tourAnterior.cupos_disponibles + reserva.cantidad_personas 
            },
            { 
              where: { id: reserva.tour_id },
              transaction: t,
            }
          );
        }
      }
    }

    // Actualizar la reserva
    const reservaActualizada = await Reserva.update(
      {
        tour_id: tour_id || reserva.tour_id,
        nombre_cliente: nombre_cliente || reserva.nombre_cliente,
        email_cliente: email_cliente || reserva.email_cliente,
        telefono_cliente: telefono_cliente || reserva.telefono_cliente,
        fecha_reserva: fecha_reserva || reserva.fecha_reserva,
        cantidad_personas: cantidad_personas || reserva.cantidad_personas,
        estado: estado || reserva.estado,
        notas: notas !== undefined ? notas : reserva.notas,
      },
      {
        where: { id },
        transaction: t,
        returning: true,
      }
    );

    await t.commit();

    // Obtener la reserva actualizada con los datos del tour
    const reservaCompleta = await Reserva.findByPk(reservaActualizada.id, {
      include: [
        {
          model: Tour,
          as: 'tour',
          attributes: ['id', 'nombre', 'destino', 'imagenUrl'],
        },
      ],
    });

    res.status(200).json({
      success: true,
      message: 'Reserva actualizada exitosamente',
      reserva: reservaCompleta,
    });
  } catch (error) {
    await t.rollback();
    console.error('Error al actualizar la reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar la reserva',
      error: error.message,
    });
  }
};

// Eliminar una reserva (borrado lógico)
exports.eliminarReserva = async (req, res) => {
  const t = await sequelize.transaction();

  try {
    const { id } = req.params;

    // Buscar la reserva
    const reserva = await Reserva.findByPk(id, { transaction: t });
    
    if (!reserva) {
      await t.rollback();
      return res.status(404).json({
        success: false,
        message: 'Reserva no encontrada',
      });
    }

    // Si la reserva está confirmada, devolver los cupos al tour
    if (reserva.estado === 'confirmada') {
      const tour = await Tour.findByPk(reserva.tour_id, { transaction: t });
      
      if (tour) {
        await Tour.update(
          { 
            cupos_disponibles: tour.cupos_disponibles + reserva.cantidad_personas 
          },
          { 
            where: { id: reserva.tour_id },
            transaction: t,
          }
        );
      }
    }

    // Realizar borrado lógico
    await reserva.update(
      { activo: false },
      { transaction: t }
    );

    await t.commit();

    res.status(200).json({
      success: true,
      message: 'Reserva eliminada exitosamente',
    });
  } catch (error) {
    await t.rollback();
    console.error('Error al eliminar la reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la reserva',
      error: error.message,
    });
  }
};

// Obtener estados de reserva
exports.obtenerEstadosReserva = (req, res) => {
  try {
    const estados = [
      { id: 'pendiente', nombre: 'Pendiente' },
      { id: 'confirmada', nombre: 'Confirmada' },
      { id: 'cancelada', nombre: 'Cancelada' },
      { id: 'completada', nombre: 'Completada' },
    ];

    res.status(200).json({
      success: true,
      estados,
    });
  } catch (error) {
    console.error('Error al obtener los estados de reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener los estados de reserva',
      error: error.message,
    });
  }
};
